Most common unmanaged resources are network connections, database connections, working with OS resources like files, windows etc. 

Even though garbage collector tracks unmanaged resources

Implement dispose pattern to enable deterministic release of unmanaged resources. 

Override Finalize method. Finalization enables non-deterministic of unmanaged resources when IDisposable pattern fails. 

IDisposable pattern is deterministic way to help clean up resources, when IDisposable fails, Finalize method can be used to non-deterministically clean up resources. 

Gc.SurpressFinalize : This is called from Dispose method to prevent finalizer from executing. 

Garbage Collection:
Each time you create a new object, the common language runtime allocates memory for the object from the managed heap. As long as adress space is available in the managed heap, the runtime continues to allocate space for the new objects. 

CLR garbage collector serves as an automatic memory manager. 
- Help you manage memory
- Allocates objects on the managed heap efficiently. 
- Reclaims objects that are no long being used.  
- Provides memory safety


Fundamentals of memory:
Each process has its own virtual address space. All processes share the same physical memory and share the page file if there is one. 

- a 32 bit machine has 2 GB user mode virtual address space. 

- You only work with virtual address space and never manipulate physical memory directly. 

Virtual memory can be in 3 states:
Free: The block of memory has no references and available for allocation. 

Reserved: The block of memory is available for use and can not be used for other processes. However, you cannot store data to this memory block until it is committed. 

Commited: THe block of memory is assigned to physical storage. 

- Virtual address space can get fragmented. This means in every garbage collection, there are holes or free blocks in the address space. 

---------------------------------------------------------------------------------------------

Mark and sweep garbage collector. 
Mark : finding live objects
Sweep : reclaim dead objects.
Compact : Put live objects together. 

Workstation GC is used for client Apps. WPF apps, console apps etc.
There is a single thread that does Garbage Collection. 
Concurrent and none Concurrent
CLR creates a special thread for GC. Schedules threads for cleanup. 
Concurrent - GC thread runs concurrently with application threads and occasionaly causes very short suspensions and stops other threads.
Non-Concurrent - There is no special GC thread. Application threads talks to GC. This is a bad idea. There might be long suspensions and pauses. 

Workstation GC doesn't use all CPU cores.

Garbage Collection - Pros and Limits 
https://social.msdn.microsoft.com/Forums/en-US/286d8c7f-87ca-46b9-9608-2b559d7dc79f/garbage-collection-pros-and-limits?forum=csharpgeneral


On the server GC. CLR creates a GC thread per logical core. When GC is needed, these threads awakens all together and cleans up resources. 

If you have 4 physical CPU with hyper threading enabled, you app will create 8 GC threads. 

GC can be parallelized quite well. Server GC is way faster. 

Each CPU allocates its memory, thus improves cache localitly. 

When does Garbage Collection occurs?
- When system has low physical memory. Either OS or host notifies low memory.
- There is a threshold for running applications which is adjusted as application runs. When this threshold is surpassed, GC kicks in. 
- When GC.Collect is invoked. 

The managed heap
CLR allocates segment of memory from Operating system to store and manage objects, this area is called managed heap. 

There is a managed heap per each managed process. To reserve memory, Garbage Collector calls VirtualAlloc function and reserves a segment of memory at a time for managed applications. Garbage Collector also reserve and release segments as needed. 

** fewer objects allocated on the heap, less work garbage collector has to do. 

When GC collection is triggered, memory occupied by dead objects is reclaimed. 
Mark, sweep and compact is used in this process. This phase makes heap smaller and helps allocated objects to stay together to preserve locality. 

Frequency and duration of GC depends on number of allocations and the amount of survived objects in managed heap. 

There is LOH, large object heap and small object heap. LOH contains very large objects which are bigger than 85K.

The heap is diveded into generations to handle long lived and short lived objects. Garbage Collection most of the time focuses on short lived objects that occupies small parts of the heap. 

Generation 0: Youngest generation, contains very short lived, transient objects. New objects by default  created on this generation, unless they are greater than 85K.

Generation 1: Short lived objects that survives a garbage collection moves on the generation 1. This generation is a buffer between generations. 

Generation 2: This generation contains long lived objects. Objects that survive multiple garbage collections. 

Garbage Collector is responsible for cleaning up in that specific generation and younger generations. A generation 2 garbage collection means full garbage collection.  