Most common unmanaged resources are network connections, database connections, working with OS resources like files, windows etc. 

 

Override Finalize method. Finalization enables non-deterministic of unmanaged resources when IDisposable pattern fails. 

IDisposable pattern is deterministic way to help clean up resources, when IDisposable fails, Finalize method can be used to non-deterministically clean up resources. 

Gc.SurpressFinalize : This is called from Dispose method to prevent finalizer from executing. 
 
 



Using unmanaged resources:
If your managed objects uses unmanaged object by using you will have to explicitly free the resources. 

You need to use finalizers to cleanup unmanaged resources. When there is a finalizable object discovered to be dead, its finalizer is put in a finalizer queue. When the finalizer method is executing it needs to place on to f-reachable-queue. 



---------------------------------------------------------------------------------------------

 

Workstation GC is used for client Apps. WPF apps, console apps etc.
There is a single thread that does Garbage Collection. 
Concurrent and none Concurrent
CLR creates a special thread for GC. Schedules threads for cleanup. 
Concurrent - GC thread runs concurrently with application threads and occasionaly causes very short suspensions and stops other threads.
Non-Concurrent - There is no special GC thread. Application threads talks to GC. This is a bad idea. There might be long suspensions and pauses. 

Workstation GC doesn't use all CPU cores.

Garbage Collection - Pros and Limits 
https://social.msdn.microsoft.com/Forums/en-US/286d8c7f-87ca-46b9-9608-2b559d7dc79f/garbage-collection-pros-and-limits?forum=csharpgeneral


On the server GC. CLR creates a GC thread per logical core. When GC is needed, these threads awakens all together and cleans up resources. 


GC can be parallelized quite well. Server GC is way faster. 

Each CPU allocates its memory, thus improves cache localitly. 





*******
if F-Reachable queue fills up faster than finalizer thread to cope with then you have a memory leak. 


WeakReferences:
WeakReferences are reference types that can be collected by GC under low memory situation even if they are in use. 

Such as cached objects. 