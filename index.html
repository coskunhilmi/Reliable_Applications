<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Building reliable applications</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section><h2>Building reliable applications</h2></section>

				<section>
					<section>
						<h3>Threading and Asynchrony</h3>
					</section>
					<section>
						<p>
							In early operating systems (16 bit) there were no threads. when a program runs into Infinite loop, deadlock or some sort, whole machine freezes. 
						</p>

						<p>
							It is not possible to determine if a program will halt or not. <a href="https://www.cs.odu.edu/~toida/nerzic/390teched/computability/unsolv-1.html" target="firat">Halting problem</a> is undecidable hence unsolvable.
						</p>
					</section>
					<section>
						<p>
							With new 32 bit Operating Systems, threads were introduced. Threads do not make a system faster. 
						</p>
						<p>
							Main purpose of threads is reliability and robustness.
						</p>
					</section>

					<section>
						<p>When a process is created, it gets its virtual address space and isolates Memory. When a thread is created it gets its own Memory and CPU isolation.
						</p>

						<p>Process can be thought of virtualization of RAM. Threading can be thought of virtualizing CPU.</p>

						<p>Of course, virtualization comes with a cost.</p>
					</section>

					<section>
						<p>While OS is running, it can execute only one thread at a given time on a logical processor. </p>
						<p>If you have a computer with 4 physical cores and 8 logical cores, you can only execute 8 threads at a given time.</p>
					</section>

					<section>
						<p>Context switching occurs while OS is changing threads to execute.</p>
					</section>

					<section>
						<p>If you have a long running task or infinite loop, OS lets that thread runs for a while and then context switches. Runs another thread for a while, then switches back. It lets infinite loop a little bit more then preemptively terminates that thread.</p>

						<p>Infinite loop does not kill Operating system.</p>
					</section>

					<section>
						<p>Threads can improve performance only on multi-core machines.</p>
					</section>

					<section>
						<p>When a thread is created, OS creates a data structure which is called thread kernel object that contains information about priority, date created, state etc.</p>

						<p>Thread has a CPU dependent data structure which is called register set context. All other data structures are CPU agnostic. But context requires information about CPU architecture.</p>
					</section>

					<section>
						<p>Every thread has usermode and kernel mode data structure. This data structures contains information about exception block, TLS, GUI etc.</p>
					
						<p>Exception handling occurs per thread, other threads are not aware of an exception happening in a thread.</p>
					</section>

					<section>
						<p>Whenever a thread is created, it allocates memory for thread context, user mode data and stacks (user mode stack, kernel mode stack).
						</p>
					</section>

					<section>
						<p>A thread comes with lots of overhead. But it is required for a robust and reliable operating system.</p>
					</section>

					<section>
						<p>A thread can be in two states. It is either waiting for IO or running and doing computation.</p>

						<p>A thread is either CPU bound or IO bound. Most of the time IO bound.</p>
					</section>

					<section>
						<p>IRP is IO request packet is created whenever a thread needs to do some IO. IRP is a data structure that contains handle of the resource, offset, number of bytes to read, offset of the byte array in the heap etc. </p>
					</section>

					<section>
						<p>IRP moves in the path below and comes back.</p>
						<p>User code -> Thread User mode -> Thread Kernel Mode -> OS (IRP dispatcher)-> Device driver</p>
					</section>

					<section>
						<p>Each device has its own IRP queue. When the IRP is passed to device, the thread is blocked. However, it is not in runnable state. When IO device completes, it triggers IO completion port and wakes up thread and goes back to processing.</p>

						<p>This is how synchronous IO workds.</p>
					</section>

					<section>
						<p>In Asynchronous mode, IRP is sent down the stack, then thread goes back threadpool.</p>

						<p>var result = await file.ReadyAsync();</p>

						<p>This returns a Task that is supposed to complete in the future. Now the thread is not blocked and can do different things. Await keyword allows thread to return immediately.</p>
					</section>

					<section>
						<p>Once device finishes processing, it sends IRP back to IOCP then to CLR which spawns a thread continues processing your code.</p>
					</section>

					<section>
						<p>Async functions are state machine objects.</p>
					</section>

					<section>
						<p>Await keyword captures thread current state and data. await keyword uses synchronization context so that correct application model is used.</p>
					</section>

					<section>
						<p>Whenever you use async/await always use ConfigureAwait(false)</p>
					</section>

					<section>
						<p>ConfigureAwait(false) ignores synchronization context, because some tasks may complete synchronously.</p>
					</section>

					<section>
						<p>When you are building framework functions, always use ConfigureAwait(false), independent of application model, asp.net, wcf, wpf etc.</p>
					</section>

					<section>
						<p>Asynchrony improves responsiveness.</p>
						<p>Async methods are non blocking.</p>
					</section>

					<section>
						<p>Synchronous programming model: Threads performs each job in a sequence. Next job begins when previous ends.</p>
					</section>

					<section>
						<p>Parallel programming model: Multiple thrads work at the same time, concurrently. Each thread performs a job.</p>
					</section>

					<section>
						<p>Async programming model: A thread starts a job and while it is awaiting for a response, it starts next job and so forth.</p>
					</section>
				</section>


			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});
		</script>
	</body>
</html>
