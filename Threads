Threads

In early operating systems there were no threads. 
The problem with this OS was with long running programs. When a program enters an infinite loop or deadlocks, whole machine freezes. 

This was a bad experience for end users. 

In 32 bit OS of windows, threads were added for reliability and robustness. Threads dont make a system run faster. Main purpose is reliability and robustness. 

When user creates a new process, each process gets a virtual address space, so memory gets isolated. Process can be thought of virtualizing the RAM. Threads can be thought of virtualizing the CPU. 

Context switching occurrs while OS is changing threads to execute. 

When a long running task comes along or infinite loop, OS lets that thread run for a quantum amount of time. OS preemptively context swithces away and runs another thread. Infinite loops can continue a bit more but is killed eventually. But infinite loops does not kill the OS. 

One CPU can run one thread at a time. 

Threads can give you improved performance only on the multi-core machines. 

Threads are virtualization technology which have overheads. 

Whenever a thread is created on the system, OS creates a data structure that represents thread, which is called thread kernel object, priority, data created, state etc. 

Thread has register set context, aka context. The only data structure in the operating sytem that is CPU dependent. All other data structures are CPU agnostic. 

Every thread has usermode data structure, aka Thread Environment Block. Default size is 4KB. Contains exception block. TLS, UI.

Exception handling occurs per thread. A thread experiences an exception. Other threads do not know that an exception is happening. 

Stacks , user mode stack, kernel mode stack. 


Whenever you create a thread, you allocate memory for thread context, user mode data and stacks.  

Createing a thread comes with lots of overhead in terms of memory allocation which need allocation as well, that takes CPU time. 


Context switch in Operating system is expensive as well. Every context switch, OS takes a thread saves its data. Then schedule the next thread to run. If the next thread belongs to a different process, OS swtches virtual address space. So the cost goes even higher. Then takes thread bytes and copy them on the CPU registers. After switching CPU usually sufferes from cache misses. 

This is very tiring and lots of overhead but is required for a robust OS. 

In a computer with 4 physical and 8 logical cores, you can have 8 thread at a given time. 

A thread can be in two states.
	Blocked waiting for IO
	Running and doing computation. 

Are the process mostly IO bound or Compute bound?
	Mostly IO.

IRP : IO request packet which is a data structure that contains handle of the file, offset, number of bytes to read, offset of the byte array in managed head etc. 

When a thread begins an IO operation it creates a IRP, switches from usermode to kernel mode. Passes the IRP down to kernel. Kernel dispatches the IRP to the device. 

Every device has its own IRP queue. Device starts doing the IO operations. While device doing this threads are blocked. OS suspends the thread. It is not scheduled to CPU. Thread is a non runnable state. 
When the IO device completes, threads wakes up and goes back in the stack and continues where its left of.

This is how synchronous IO works. 

In asynchronous mode, when a start starts an IP, it sends IRP down the stack from executing code, to user mode then to kernel mode which sends IRP to device driver queue. 

var result = await file.ReadyAsync();

This returns a Task that is supposed to complete in the future. Now the thread is not blocked and can do different things. Await keyword allows thread to return immediately. 

Once device finished processing, it sends back IRP and byte array back to IOCP (IO Completion Port) and then to CLR thread pool, which spawns a thread and continiues processing your code. 

Async functions are state machine objects. 


Await keyword captures thread current state and data. 
await keyword uses synchronization context so that correct application model is used. 


Whenever you use async/await always use ConfigureAwait(false) 

ConfigureAwait(false) ignores SynchronizationContext, because some tasks may complete synchronously. 

When you are building framework functions, always use ConfigureAwait(false), independent of application model, asp.net, wcf, wpf etc.